package edu.cornell.SocialDPU.Storage;



//*******************************************************************
import java.io.File;

import android.content.ContentValues;
import android.content.Context;
import android.database.SQLException;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteOpenHelper;
import android.database.sqlite.SQLiteDatabase.CursorFactory;
import android.util.Log;


/**
 * Database adapter for storing all data produced in the social dpu
 * @author shuva
 *
 */
public class MyDBAdapter {
	
	
	private String DATABASE_NAME;
	private static final int DATABASE_VERSION = 3;
	private static final long MAX_INSERT_PER_TRANSACTION = 1500; // write after 1500 transactions
	private long insert_count;
	public boolean database_online;

	/*
	 * database tables
	 */
	private static final String CREATE_TABLE_EVENT_IDS = "CREATE TABLE IF NOT EXISTS " +
	"event_ids(event_id INTEGER PRIMARY KEY AUTOINCREMENT);";
	private static final String CREATE_TABLE_SOURCES = "CREATE TABLE IF NOT EXISTS " +
	"sources(source_id INTEGER PRIMARY KEY ASC AUTOINCREMENT, " +
	"source_name TEXT UNIQUE ON CONFLICT IGNORE, source_sampling_rate INTEGER);";	
	
	//this table stores all the data generated by the audio event
	private static final String  CREATE_TABLE_EVENTS = "CREATE TABLE IF NOT EXISTS " +
	"events(event_id INTEGER ASC, event_time DATETIME,event_source_id INTEGER REFERENCES sources(source_id), " +
	"event_source_message_type_id INTEGER, event_data BLOB, sync_id INTEGER);";
	private static final String CREATE_TABLE_INFERENCE = "CREATE TABLE IF NOT EXISTS " +
	"inference(inference_time DATETIME ASC, inference_is_start BOOLEAN, inference_type INTEGER, inference_name TEXT);";
	private static final String CREATE_TABLE_LABEL = "CREATE TABLE IF NOT EXISTS " +
	"label(label_time DATETIME ASC, label_is_start BOOLEAN, label_type INTEGER, label_name TEXT);";
	private static final String CREATE_TABLE_LOCATION = "CREATE TABLE IF NOT EXISTS " +
	"location(location_time DATETIME ASC, location_is_start BOOLEAN, location_lat FLOAT, location_lon FLOAT);";
	private static final String CREATE_TABLE_EXPERIMENTS = "CREATE TABLE IF NOT EXISTS " +
	"experiments(experiment_id INTEGER PRIMARY KEY ASC AUTOINCREMENT, experiment_name TEXT, " +
	"experiment_start DATETIME, experiment_end DATETIME);";
	
	private static final String TABLE_NAME_EVENT_IDS = "event_ids";
	private static final String TABLE_NAME_SOURCES = "sources";
	private static final String TABLE_NAME_EVENTS = "events";
	private static final String TABLE_NAME_INFERENCES = "inference";
	private static final String TABLE_NAME_LABEL = "label";
	private static final String TABLE_NAME_LOCATION = "location";
	private static final String TABLE_NAME_EXPERIMENTS = "experiments";

	// Variable to hold the database instance
	private SQLiteDatabase db;
	// Context of the application using the database.
	private final Context context;
	// Database open/upgrade helper
	private myDbHelper dbHelper;

	/**
	 * Constructor
	 * @param _context, reference to the class that created the database
	 */
	public MyDBAdapter(Context _context) {
		
		context = _context;
		dbHelper = new myDbHelper(context, DATABASE_NAME, null,
				DATABASE_VERSION);
		insert_count = 0;

	}

	/**
	 * Contructor
	 * @param _context, reference to the class that created the database
	 * @param database_name, database name
	 */
	public MyDBAdapter(Context _context, String database_name) {
		context = _context;

		this.DATABASE_NAME = database_name;
		//???
		dbHelper = new myDbHelper(context, DATABASE_NAME, null,
				DATABASE_VERSION);
		
	}

	
	/**
	 * Open the database
	 * @return returns a database handler object
	 * @throws SQLException
	 */
	public MyDBAdapter open() throws SQLException {
		
		db = dbHelper.getWritableDatabase();
		database_online = true;
		return this;
	}

	/**
	 * close the database
	 */
	public void close() {
		database_online = false;
		if(db.inTransaction()){
			db.setTransactionSuccessful();
			db.endTransaction();		
		}
		insert_count=0;
		db.close();

	}

	
	/**
	 * Returns an event ID to insert new objects
	 * @return
	 */
	public long getNewEventID(){
		ContentValues value = new ContentValues();
		value.putNull("event_id");

		return insertEntry(TABLE_NAME_EVENT_IDS, value);
	}


	// Register sources, make query first
	public void registerSource(String source_name, int source_sampling_rate){

		ContentValues value = new ContentValues();
		value.putNull("source_id");
		value.put("source_name", source_name);
		value.put("source_sampling_rate", source_sampling_rate);
		insertEntry(TABLE_NAME_SOURCES, value);

	}

	/**
	 * This functions store the audio data and inference values inside a sqlite database
	 * @param event_time, when data was created
	 * @param event_source_id
	 * @param event_source_message_type_id
	 * @param event_data, data of audio in byte array format
	 */
	public void insertEntryEvents(long event_time, int event_source_id, int event_source_message_type_id, byte[] event_data,int sync_id){
		ContentValues value = new ContentValues();
		value.put("event_id", getNewEventID());
		value.put("event_time", ((double)event_time)/1000);
		value.put("event_source_id", event_source_id);
		value.put("event_source_message_type_id", event_source_message_type_id);
		value.put("event_data", event_data);
		value.put("sync_id", sync_id);
		insertEntry(TABLE_NAME_EVENTS, value);

	}
	public void insertEntryExperiments(String experiment_name, long experiment_start, long experiment_end){
		ContentValues value = new ContentValues();
		value.put("experiment_name", experiment_name);
		value.put("experiment_start", experiment_start);
		value.put("experiment_end", experiment_end);
		insertEntry(TABLE_NAME_EXPERIMENTS, value);
	}
	public void insertEntryInference(long inference_time, boolean inference_is_start, int inference_type, String inference_name){
		ContentValues value = new ContentValues();
		value.put("inference_time", ((double)inference_time/1000));
		value.put("inference_is_start", inference_is_start);
		value.put("inference_type", inference_type);
		value.put("inference_name", inference_name);
		insertEntry(TABLE_NAME_INFERENCES, value);
		Log.i("Inference Tag", "" + inference_name + "  " + inference_is_start);
	}
	public void insertEntryLabel(long lable_time, boolean label_is_start, int label_type, String label_name){

		ContentValues value = new ContentValues();
		value.put("label_time", ((double)lable_time/1000));
		value.put("label_type", label_type);
		value.put("label_is_start", label_is_start);
		value.put("label_name", label_name);
		insertEntry(TABLE_NAME_LABEL, value);
		Log.i("Label Tag", "" + label_name + "  " + label_is_start);
	}

	public void insertEntryLocation(long location_time, boolean location_is_start, double location_lat, double location_lon){		

		ContentValues value = new ContentValues();
		value.put("location_time", location_time);
		value.put("location_is_start", location_is_start);
		value.put("location_lat", location_lat);
		value.put("location_lon", location_lon);
		insertEntry(TABLE_NAME_LOCATION, value);

	}



	/**
	 * Insert entries into the database
	 * @param table_name, what table to insert to
	 * @param value, what values are getting inserted
	 * @return returns the id of the latest insertion
	 */
	private long insertEntry(String table_name, ContentValues value) {
		long index = 0;


		try{
			if (insert_count == 0) db.beginTransaction();

			index = (int)db.insert(table_name, null, value);
			insert_count++;

			if(insert_count == MAX_INSERT_PER_TRANSACTION  ) {
				Log.d("XY", "trasaction sucessful");

				db.setTransactionSuccessful();
			}
		}catch (SQLException e) {
		} finally {
			if(insert_count == MAX_INSERT_PER_TRANSACTION  ){ 
				insert_count=0;
				db.endTransaction();
			}
		}

		return index;
	}



	/**
	 * makes sure what table to insert data to
	 * @param obj
	 */
	public void insertMltObj(Object obj){
		ML_toolkit_object mltobj = (ML_toolkit_object)obj;

		//0 = audio, 1=accelerometer, 2=location, 3 = audio features, 4 = accel features, 5 = audio inference, 6 = accel inference, 7 = label_start , 8 = label_end 

		if(mltobj.datatype < 5 || mltobj.datatype > 8 )//means no inference result or label information
			insertEntryEvents(mltobj.timestamp, mltobj.datatype, 0, mltobj.data, mltobj.sync_id);
		else if(mltobj.datatype ==  5) //go to inferred results
			insertEntryInference(mltobj.timestamp, mltobj.isStart, 0, mltobj.inferred_results_or_label_info); // 0 means audio inference
		else if(mltobj.datatype ==  6) //go to inferred results
			insertEntryInference(mltobj.timestamp, mltobj.isStart, 1, mltobj.inferred_results_or_label_info); // 1 means accel inference
		else if(mltobj.datatype ==  7) 
			insertEntryLabel(mltobj.timestamp, true, 0, mltobj.inferred_results_or_label_info);
		else if(mltobj.datatype ==  8)
			insertEntryLabel(mltobj.timestamp, false, 0, mltobj.inferred_results_or_label_info);

	}


	/**
	 * reve all entries from the database
	 * @return
	 */
	public boolean removeAllEntries() {
		return db.delete(TABLE_NAME_EVENT_IDS, null, null) > 0 && 
		db.delete(TABLE_NAME_SOURCES, null, null) > 0 &&
		db.delete(TABLE_NAME_EVENTS, null, null) > 0 &&
		db.delete(TABLE_NAME_INFERENCES, null, null) > 0 &&
		db.delete(TABLE_NAME_LABEL, null, null) > 0 &&
		db.delete(TABLE_NAME_LOCATION, null, null) > 0 &&
		db.delete(TABLE_NAME_EXPERIMENTS, null, null) > 0
		;

	}

	/**
	 * Size of the database file. It used to create new files where the db reaches a certain size
	 * @return
	 */
	public long getDbSize()
	{
		File file = new File(this.getPathOfDatabase());
		return file.length();
	}

	/**
	 * helper class for the db adapter
	 * @author shuva
	 *
	 */
	private static class myDbHelper extends SQLiteOpenHelper {

		public myDbHelper(Context context, String name, CursorFactory factory,
				int version) {
			super(context, name, factory, version);
		}

		// Called when no database exists in disk and the helper class needs
		// to create a new one.
		@Override
		public void onCreate(SQLiteDatabase _db) {
			_db.execSQL(CREATE_TABLE_SOURCES);
			_db.execSQL(CREATE_TABLE_EVENT_IDS);
			_db.execSQL(CREATE_TABLE_EVENTS);
			_db.execSQL(CREATE_TABLE_INFERENCE);
			_db.execSQL(CREATE_TABLE_LABEL);
			_db.execSQL(CREATE_TABLE_EXPERIMENTS);			
			_db.execSQL(CREATE_TABLE_LOCATION);
		}

		// Called when there is a database version mismatch meaning that the
		// version
		// of the database on disk needs to be upgraded to the current version.
		@Override
		public void onUpgrade(SQLiteDatabase _db, int _oldVersion,
				int _newVersion) {
			// Log the version upgrade.
			Log.w("TaskDBAdapter", "Upgrading from version " + _oldVersion
					+ " to " + _newVersion
					+ ", which will destroy all old data");

			// Upgrade the existing database to conform to the new version.
			// Multiple
			// previous versions can be handled by comparing _oldVersion and
			// _newVersion
			// values.

			// The simplest case is to drop the old table and create a new one.
			_db.execSQL("DROP TABLE IF EXISTS " + CREATE_TABLE_SOURCES);	// correct?
			_db.execSQL("DROP TABLE IF EXISTS " + CREATE_TABLE_EVENT_IDS);  // correct?
			_db.execSQL("DROP TABLE IF EXISTS " + CREATE_TABLE_EVENTS);  // correct?
			_db.execSQL("DROP TABLE IF EXISTS " + CREATE_TABLE_INFERENCE);	// correct?
			_db.execSQL("DROP TABLE IF EXISTS " + CREATE_TABLE_LOCATION);  // correct?			
			_db.execSQL("DROP TABLE IF EXISTS " + CREATE_TABLE_LABEL);  // correct?
			_db.execSQL("DROP TABLE IF EXISTS " + CREATE_TABLE_EXPERIMENTS);	// correct?

			// Create a new one.
			onCreate(_db);
		}
	}

	public String getPathOfDatabase()
	{
		return db.getPath();
	}


}